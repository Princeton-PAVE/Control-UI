# Local Autonomous Vehicle Control Plan (Serverless / Point-to-Point)

## Overview
This plan removes the need for a cloud-hosted server. Instead, the **Vehicle itself acts as the web server**. The user simply connects their laptop to the same Wi-Fi network as the vehicle (or connects directly to the vehicle's Hotspot) and opens the vehicle's IP address in a browser.

### Key constraints addressed:
*   **No Hosting:** The Flask server runs on the vehicle's onboard computer.
*   **Just Endpoints:** We use standard HTTP endpoints (`/offer`, `/answer`) to establish the connection, avoiding complex WebSocket servers if desired.
*   **Modern Software:** Uses **WebRTC** for sub-200ms video latency (far superior to MJPEG) and **React** for the UI.

## Architecture

1.  **Vehicle (Server):**
    *   Runs **Flask** to serve the React files and handle signaling.
    *   Runs **aiortc** (Python WebRTC) to capture camera frames and listen for control data.
    *   Exposes endpoints: `GET /` (UI), `POST /offer` (Signaling).

2.  **User (Client):**
    *   Runs a browser with the **React App**.
    *   Connects to `http://<VEHICLE_IP>:5000`.
    *   Sends control commands (WASD/Joystick) directly via WebRTC Data Channels.

---

## Part 1: The Vehicle Code (Python + Flask)

**File:** `vehicle_server.py`
**Dependencies:** `pip install flask aiortc opencv-python av`

```python
import asyncio
import json
import logging
import cv2
from flask import Flask, render_template, Response, request, jsonify
from flask_cors import CORS
from aiortc import RTCPeerConnection, RTCSessionDescription, VideoStreamTrack
from av import VideoFrame

app = Flask(__name__, static_folder='../client/build', static_url_path='/')
CORS(app)

# --- Hardware/Camera Logic ---
class CameraVideoStreamTrack(VideoStreamTrack):
    def __init__(self):
        super().__init__()
        self.cap = cv2.VideoCapture(0) # Open default camera

    async def recv(self):
        pts, time_base = await self.next_timestamp()
        ret, frame = self.cap.read()
        if not ret:
            return None

        # Resize/Optimize frame here if needed
        frame = cv2.resize(frame, (640, 480)) 

        # Convert to av.VideoFrame
        av_frame = VideoFrame.from_ndarray(frame, format="bgr24")
        av_frame.pts = pts
        av_frame.time_base = time_base
        return av_frame

# --- Global State ---
pcs = set()

# --- Web Server Endpoints ---
@app.route('/')
def index():
    # Serve the React App (ensure React is built to ../client/build)
    return app.send_static_file('index.html')

@app.route('/offer', methods=['POST'])
async def offer():
    params = request.json
    offer = RTCSessionDescription(sdp=params['sdp'], type=params['type'])

    pc = RTCPeerConnection()
    pcs.add(pc)

    # Add Video Track
    pc.addTrack(CameraVideoStreamTrack())

    # Handle Control Data (DataChannel)
    @pc.on("datachannel")
    def on_datachannel(channel):
        @channel.on("message")
        def on_message(message):
            data = json.loads(message)
            print(f"Control Received: {data}")
            # TODO: Hardware code here (e.g. GPIO.output(data['throttle']))

    @pc.on("connectionstatechange")
    async def on_connectionstatechange():
        if pc.connectionState == "failed":
            await pc.close()
            pcs.discard(pc)

    # Set Remote & Local Descriptions
    await pc.setRemoteDescription(offer)
    answer = await pc.createAnswer()
    await pc.setLocalDescription(answer)

    return jsonify({
        "sdp": pc.localDescription.sdp,
        "type": pc.localDescription.type
    })

def run_server():
    # Note: aiortc requires asyncio loop, detailed setup needed for production
    app.run(host='0.0.0.0', port=5000, threaded=True)

if __name__ == "__main__":
    # For dev purposes only. 
    # In production, use Hypercorn/Uvicorn to mix Flask + Async properly
    app.run(host='0.0.0.0', port=5000)
```

---

## Part 2: The User Interface (React)

**File:** `src/App.js`
**Dependencies:** `npm install react-use-websocket` (Optional, standard fetch is fine)

```jsx
import React, { useEffect, useRef, useState } from 'react';

function App() {
  const videoRef = useRef(null);
  const pc = useRef(new RTCPeerConnection());
  const [status, setStatus] = useState("Disconnected");

  // Input Handling
  const handleKeyDown = (e) => {
    if (pc.current.dataChannel?.readyState === "open") {
      const command = { key: e.key, type: "DOWN" };
      pc.current.dataChannel.send(JSON.stringify(command));
    }
  };

  useEffect(() => {
    // 1. Setup WebRTC
    pc.current.ontrack = (event) => {
      if (videoRef.current) {
        videoRef.current.srcObject = event.streams[0];
      }
    };

    // 2. Create Data Channel for Controls
    const dc = pc.current.createDataChannel("controls");
    pc.current.dataChannel = dc;

    dc.onopen = () => setStatus("Connected (Ready to Drive)");

    // 3. Negotiate Connection (Signaling via HTTP Endpoint)
    const startConnection = async () => {
      const offer = await pc.current.createOffer();
      await pc.current.setLocalDescription(offer);

      // Send Offer to Vehicle Endpoint
      const response = await fetch('/offer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          sdp: offer.sdp,
          type: offer.type
        })
      });

      const answer = await response.json();
      await pc.current.setRemoteDescription(answer);
    };

    startConnection();

    // Cleanup
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  return (
    <div style={{ textAlign: 'center', backgroundColor: '#222', color: '#fff', height: '100vh' }}>
      <h1>Autonomous Vehicle Teleop</h1>
      <h3>Status: {status}</h3>
      <video 
        ref={videoRef} 
        autoPlay 
        playsInline 
        muted 
        style={{ width: '80%', border: '2px solid red' }} 
      />
      <p>Use Keyboard to Control</p>
    </div>
  );
}

export default App;
```

## Part 3: How to Run (The "No Hosting" Workflow)

1.  **On the Vehicle Computer:**
    *   Save the Python code as `server.py`.
    *   Build the React app: `npm run build`.
    *   Copy the `build` folder to the same directory as `server.py` (rename it `../client/build` or adjust the path in python).
    *   Run: `python server.py`.
2.  **On the User Computer:**
    *   Ensure you are on the same Wi-Fi.
    *   Find the vehicle's IP (e.g., `192.168.1.50`).
    *   Open Chrome and visit `http://192.168.1.50:5000`.
    *   The video should appear immediately.

## Why this works
This architecture treats the vehicle as an **IoT Appliance**. It hosts its own control site. The "Signaling" is done over a simple HTTP POST request to the vehicle's IP, and then the heavy video traffic takes over via WebRTC P2P (UDP).